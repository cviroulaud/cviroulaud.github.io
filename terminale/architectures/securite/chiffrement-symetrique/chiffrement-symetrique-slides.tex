\documentclass[svgnames,11pt]{beamer}
\input{/home/tof/Documents/Cozy/latex-include/preambule_commun.tex}
\input{/home/tof/Documents/Cozy/latex-include/preambule_beamer.tex}
%\usepackage{pgfpages} \setbeameroption{show notes on second screen=left}
\author[]{Christophe Viroulaud}
\title{Chiffrement symétrique}
\date{\framebox{\textbf{Archi 20}}}
%\logo{}
\institute{Terminale - NSI}

\begin{document}
\begin{frame}
    \titlepage
\end{frame}
\begin{frame}
    \frametitle{}

    La communication sur internet est organisée en couches.
    \begin{center}
        \begin{tabular}{|c|}
            \hline
            Couche application (Navigateur) \\
            \hline
            Couche TCP (Transport)          \\
            \hline
            Couche IP (Internet)            \\
            \hline
            Couche réseau (Matérielle)      \\
            \hline
        \end{tabular}
        \captionof{table}{Protocole TCP/IP}
    \end{center}

\end{frame}
\begin{frame}
    \frametitle{}
    \begin{center}
        \centering
        \includegraphics[width=8cm]{ressources/serveur-web.png}
        \captionof{figure}{\centering Les paquets IP transitent sur le réseau internet en circulant de routeurs en routeurs.}
        \label{IMG}
    \end{center}
    En théorie, rien n'interdit à un routeur d'inspecter un paquet et donc d'en connaître son contenu.
    \begin{framed}
        \centering Comment chiffrer le contenu des communications?
    \end{framed}
\end{frame}
\section{Chiffrement symétrique}
\subsection{Principe}
\begin{frame}
    \frametitle{Chiffrement symétrique - Principe}

    \begin{center}
        \begin{tikzpicture}
            \node[draw] (A) at (0,0) {Chiffrement des données};
            \node[draw] (B) at (0,-4) {Déchiffrement des données};
            \draw[->,>=latex] (A) -- (B) node[midway, fill=white] {Transfert};
        \end{tikzpicture}
    \end{center}

\end{frame}
\begin{frame}
    \frametitle{}

    \begin{itemize}
        \item<1-> La source utilise une \emph{fonction de chiffrement} pour coder un message \textbf{\texttt{m}} avec une clé de chiffrement \textbf{\texttt{k}}. La fonction produit en sortie un message chiffré \textbf{\texttt{s}}.
              \begin{center}
                  \textbf{\texttt{chiffrement(m, k) $\rightarrow$ s}}
              \end{center}
        \item<2-> Le destinataire utilise une \emph{fonction de déchiffrement} pour décoder le message \textbf{\texttt{s}} avec la clé de chiffrement \textbf{\texttt{k}}. La fonction produit en sortie le message clair \textbf{\texttt{m}}.
              \begin{center}
                  \textbf{\texttt{déchiffrement(s, k) $\rightarrow$ m}}
              \end{center}
    \end{itemize}

\end{frame}
\begin{frame}
    \frametitle{}

    \begin{aretenir}[]
        Dans un chiffrement symétrique on utilise la même clé pour chiffrer et déchiffrer le message.
        \end{aretenir}

\end{frame}
\subsection{Chiffrement de César}
\begin{frame}
    \frametitle{Chiffrement de César}

    Le chiffrement de César utilise un décalage alphabétique comme clé de chiffrement. Par exemple, avec la clé \textbf{\texttt{+2}}:
    \begin{itemize}
        \item A devient C
        \item B devient D
        \item \dots
        \item Z devient B
    \end{itemize}

\end{frame}
\begin{frame}[fragile]
    \frametitle{}
    
    \begin{activite}
        Écrire la fonction \textbf{\texttt{chiffrement(message: str, cle: int) $\rightarrow$ str}} qui code \textbf{\texttt{message}}. \\
        On n'utilisera que des caractères majuscules ASCII dans le message et on supprimera les espaces.     Dans un premier temps, on ne s'occupera pas du \emph{débordement de l'alphabet}. Ainsi l'appel
\begin{center}
\begin{lstlisting}[language=Python , basicstyle=\ttfamily\small, xleftmargin=2em, xrightmargin=2em]
>>> chiffrement("Z", 1)
\end{lstlisting}
\end{center}
renverra le caractère \textbf{\texttt{[}} situé à la 91° position du code ASCII.
    \end{activite}

\end{frame}
\begin{frame}[fragile]
    \frametitle{Correction}

\begin{center}
\begin{lstlisting}[language=Python , basicstyle=\ttfamily\small, xleftmargin=0.2em, xrightmargin=0em]
def chiffrement(message: str, cle: int) -> str:
    sortie = ""
    for lettre in message:
        # code ASCII de la lettre chiffrée
        code = ord(lettre) + cle
        # ajout
        sortie = sortie+chr(code)
    return sortie
\end{lstlisting}
\end{center}

\end{frame}
\begin{frame}[fragile]
    \frametitle{}

    \begin{activite}
    Modifier la fonction pour que l'appel
\begin{center}
\begin{lstlisting}[language=Python , basicstyle=\ttfamily\small, xleftmargin=2em, xrightmargin=2em]
>>> chiffrement("Z", 1)
\end{lstlisting}
\end{center}
renvoie la lettre \textbf{\texttt{A}}
    \end{activite}

\end{frame}
\begin{frame}[fragile]
    \frametitle{Correction}

\begin{center}
\begin{lstlisting}[language=Python , basicstyle=\ttfamily\small, xleftmargin=0.2em, xrightmargin=0em]
def chiffrement(message: str, cle: int) -> str:
    sortie = ""
    for lettre in message:
        # code ASCII de la lettre chiffrée
        code = (ord(lettre) + cle) % 91  # Z = 90
        # ajustement du code ASCII
        if code < ord("A"):
            code = code+ord("A")
        # ajout
        sortie = sortie+chr(code)
    return sortie
\end{lstlisting}
\end{center}

\end{frame}
\begin{frame}
    \frametitle{}

    \begin{activite}
    Écrire la fonction \textbf{\texttt{dechiffrement(message: str, cle: int) $\rightarrow$ str}} qui déchiffre \textbf{\texttt{message}} en prenant en compte le \emph{débordement de l'alphabet}.
    \end{activite}

\end{frame}
\begin{frame}[fragile]
    \frametitle{Correction}

    

\end{frame}
\end{document}